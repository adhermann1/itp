In the Pyramid assignment, I had to create a left facing pyramid with a certain amount of stacks based on an input from the user.
To start, I put in the input function in order to start the program with the user's input. I set the variable 'stacks' to equal the outcome of this function, so that we can then plug it into our code. I did not use the integer command at first so my variable didn't go into the string. Therefore, I added the integer so that my numeric variable could be used to produce words and symbols. Next, I knew that I had to set up a chain for two different possible outcomes. I decided to use an if/else statement. I attached our yes condition, or the instance that the user plugs in a viable number within the 1-8 range, into the if statement. For the else statement, I made this the case that our user does not input a number within our range, such that it will tell them that they can only use numbers 1-8 and end the function. I orginally tried using a return function, but this was complicated for me and I decided that an if/else statement would be simpler to implement. I then used the given code in the pyramid instructions to construct my pyramid with the number input from our user. I used the outside chain for my stack variable, which I used a range of (1, stacks + 1, 1). The inside chain uses the secondary variable of j. Through this double chain, I then changed the output from the original '#' to ' ' * (8 - stacks) +'#' * stacks. Because the original code gives us a square, I knew that I had to add decreasing spaces to create the left facing pyramid and set each hash in each row to the number stack of that row. Given that the slashes plus spaces in the stack equals 8, I knew that I had to have spaces decrease from the max 7 ('' * (8 - stacks)) and then increasing hashes, one for each stack ('#' * stacks). I came to this conclusion after I had problems with spacing and number of hashes. I originally had ' ' * stacks, '#', which gave me a large space between hashes and separated hashes. I realized from  this that I needed to combine these two variables such that they happen at the same time, rather than sequencing. This allows me to put hashes and spaces next to each other, rather than alternating which is what happens when they are two separate characters. I also realized that I needed each of my stacks to only have an amount of hashes equal to the number stack. Thirdly, this helped me realize that I had to make spaces decrease with stack number. They were increasing when I just had ' ' * stacks, so putting the negative symbol on the stacks helped them decrease, while 8 is used to control how many spaces there are, as the max number of spaces can be 7 with the 1 hash stack. Additionally, I realized that I had to alter the range of my stacks. Originally, I had (1, 9, 1), which ended up creating the same height of stacks for every number. I changed this to (1, stacks + 1, 1). Given that the first digit is 0, and I cannot accept 0, I had to add 1 to the stacks, so that the code would recognize that when 1 is plugged in, that it recognizes that I need the range to stop at the 2nd digit, which is 1. My last problem was that I only needed one pyramid instead of multiple. I didn't really know what to do with j, so I originally had j in range(stacks). This ended up creating as many pyramids as I had stacks, and I only needed one pyramid, so I changed the range to j in range(1). This created one pyramid. To cap off my function, and in order to print my pyramid, I then had to add a print() function to the end of the nest.

For the FizzBuzz assignment I had to create a counter that counted all of the numbers from 1 to 100, and each number divisible by 3 had to say 'Fizz' and each number divisible by 5 had to say
' Buzz', such that numbers divisible by both 3 and 5 say 'FizzBuzz'. To first approach this, I decided to use an if/elif/else condition, set up by a for statement. I set my variable as i, and made a standard 1-100 range with (1, 101, 1). Originally I put in the divisible functions for 3 and 5 individually, then tried running the program. This left me with only Fizz and Buzz, but no FizzBuzz. I then added the combined divisible with the and connector in order to see if this would add the FizzBuzz, but I came up with the same results. I theorized that given the properties of an if/elif/else condition, I would have to make sure that I checked if a number was divisible by both of them before seeing if it is divisible by only one. Thus, I put the combined divisible at the top of my condition, and then the individual two as elifs after that, so that if a number is not divisible by both, it daisy chains to check if it divisible by at least one of them. Finally, for my else statement, I had the function print(i) so that I had regular numbers as well as FizzBuzz on my number line.
